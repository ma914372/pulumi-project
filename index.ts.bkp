import * as pulumi from "@pulumi/pulumi";
import * as k8s from "@pulumi/kubernetes";
import * as child_process from "child_process";

const config = new pulumi.Config();
const kubeconfig = config.require("kubeconfig");

const k8sProvider = new k8s.Provider("k8sProvider", { kubeconfig });

const namespace = new k8s.core.v1.Namespace("app-namespace", {
    metadata: { name: "app-namespace" },
}, { provider: k8sProvider });

const metricsServer = new k8s.yaml.ConfigFile("metrics-server", {
    file: "https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml",
}, { provider: k8sProvider });

new Promise(resolve => setTimeout(resolve, 180000)).then(() => {
    console.log("Checking Metrics Server status...");
    try {
        const result = child_process.execSync("kubectl get pods -n kube-system | grep metrics-server").toString();
        if (!result.includes("1/1")) {
            console.log("Patching Metrics Server...");
            child_process.execSync("kubectl patch deployment metrics-server -n kube-system --type='json' -p='[{\"op\": \"add\", \"path\": \"/spec/template/spec/containers/0/args/-\", \"value\": \"--kubelet-insecure-tls\"}]'");
            console.log("Restarting Metrics Server...");
            child_process.execSync("kubectl rollout restart deployment metrics-server -n kube-system");
        }
    } catch (error) {
        console.error("Error checking or patching Metrics Server:", error);
    }
});

const ingressController = new k8s.yaml.ConfigFile("ingress-controller", {
    file: "https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml",
}, { provider: k8sProvider });

const appLabels = { app: "nginx" };

const deployment = new k8s.apps.v1.Deployment("nginx-deployment", {
    metadata: { name: "nginx", namespace: namespace.metadata.name },
    spec: {
        selector: { matchLabels: appLabels },
        replicas: 3,
        template: {
            metadata: { labels: appLabels },
            spec: {
                containers: [{
                    name: "nginx",
                    image: "nginx",
                    ports: [{ containerPort: 80 }],
                    resources: {
                        requests: { cpu: "100m", memory: "128Mi" },
                        limits: { cpu: "500m", memory: "256Mi" },
                    },
                }]
            }
        }
    }
}, { provider: k8sProvider });

const hpa = new k8s.autoscaling.v2.HorizontalPodAutoscaler("nginx-hpa", {
    metadata: { name: "nginx-hpa", namespace: namespace.metadata.name },
    spec: {
        scaleTargetRef: {
            apiVersion: "apps/v1",
            kind: "Deployment",
            name: deployment.metadata.name,
        },
        minReplicas: 3,
        maxReplicas: 9,
        metrics: [{
            type: "Resource",
            resource: { name: "cpu", target: { type: "Utilization", averageUtilization: 50 } }
        }]
    }
}, { provider: k8sProvider, dependsOn: [metricsServer] });

const service = new k8s.core.v1.Service("nginx-service", {
    metadata: { name: "nginx-service", namespace: namespace.metadata.name },
    spec: {
        selector: appLabels,
        ports: [{ protocol: "TCP", port: 80, targetPort: 80 }],
        type: "ClusterIP"
    }
}, { provider: k8sProvider });

const ingress = new k8s.networking.v1.Ingress("nginx-ingress", {
    metadata: {
        name: "nginx-ingress",
        namespace: namespace.metadata.name,
        annotations: {
            "kubernetes.io/ingress.class": "nginx",
            
        },
    },
    spec: {
        ingressClassName: "nginx",
        rules: [{
            host: "nginx.local",
            http: {
                paths: [{
                    path: "/",
                    pathType: "Prefix",
                    backend: {
                        service: { name: service.metadata.name, port: { number: 80 } }
                    }
                }]
            }
        }]
    }
}, { provider: k8sProvider, dependsOn: [ingressController] });

// Export values
export const namespaceName = namespace.metadata.name;
export const deploymentName = deployment.metadata.name;
export const serviceName = service.metadata.name;
export const ingressName = ingress.metadata.name;
